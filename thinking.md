
对每种情况进行分数赋值。
需要minimax函数(剪枝)
想要对根节点进行估值，需要遍历他的子节点。
通过深搜到叶节点。
每个节点都有估值。
当前节点取哪个子节点的值取决于是max节点还是min节点
该算法使用深度优先搜索（Depth First Search）遍历决策树来填充树中间节点的利益值，叶子节点的利益值通常是通过一个利益评估函数算
总是选择最利于自己（A）的方案，而对手同样聪明，总是选择最不利与对方即A方的方案。
B总是选择候选方案中的最小值，而A总是选择候选方案中的最大值
节点的每个孩子节点代表一个候选方案
AI要考虑3步的话， 那就是搜索深度为3，那就是搜索落在那个点，3步后得分最大。这就可以和看能看3步棋的老家伙对抗了。

树的每一个点 有一个值来表明这个局面的利益值 通过估值函数来实现
还有α和β值代表值的取值范围 剪枝用

为了加快计算速度，减少计算量，可以使用Alpha-Beta剪枝算法（Alpha Beta Pruning）对搜索树进行剪枝。因为搜索树中有很多分支不需要遍历
如果当前节点是最小层节点 下节点的值小于他的上界，就应该更新，因为最小层会选利益值最小的点 怎么大都对他没关系
最大层的节点取的是下界
我们带着根节点的取值区间继续往下搜索，把这个区间赋给下一个子节点：
当发现收益值的区间产生矛盾的时候，我们当前的节点无论再怎么继续搜索，也不可能出现最优解了。这下可以放心跳过了。

通过维护一个收益的可行区间，在搜索的过程中进行剪枝操作，就是所谓的α-β剪枝。
由于α-β剪枝剪掉的点，都是必然不可能是最优解的节点，因此我们永远不会错过最优解。同时，由于及时的剪枝操作，我们大大地减少了需要搜索的节点数量，节省下来的算力就能进行更多更深层次的搜索
都站在自己的一方来求最大值， 对手的最大值前面加个负号，不就是对我来说的最小值吗? 有点绕， 但道理相信很容易理解， 这样的好处就是把求最大最小值写在一个函数里了